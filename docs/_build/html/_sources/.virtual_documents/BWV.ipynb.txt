





import os
import logging

logger = logging.getLogger()  

logFileName= r"BWV.log" 

loglevel = logging.DEBUG
logging.basicConfig(filename=logFileName
                        ,filemode='w'
                        ,level=loglevel
                        ,format="%(asctime)s ; %(name)-60s ; %(levelname)-7s ; %(message)s")    

fileHandler = logging.FileHandler(logFileName)     

logger.addHandler(fileHandler)

consoleHandler = logging.StreamHandler()
consoleHandler.setFormatter(logging.Formatter("%(levelname)-7s ; %(message)s"))

consoleHandler.setLevel(logging.INFO) # ggf. DEBUG/WARNING/ERROR
logger.addHandler(consoleHandler)

import pandas as pd
import geopandas as gpd
import networkx as nx
import glob
import re
import numpy as np
import folium
from folium.plugins import HeatMap
import doctest





dbFilename="BWV"








!pip install PT3S -U --no-deps


try:
    from PT3S import dxAndMxHelperFcts
except:
    import dxAndMxHelperFcts





m=dxAndMxHelperFcts.readDxAndMx(dbFile=os.path.join('.',dbFilename+'.db3')                                
                               #,forceSir3sRead=True 
                               #,preventPklDump=True
                               )








shapes={}
for shpFile in glob.glob(r".\GIS Daten\*.shp"):
    
    gdf=gpd.read_file(shpFile)
    
    shpFilename=os.path.basename(shpFile)
    shpFilename,tail=os.path.splitext(shpFilename)
    shapes[shpFilename]=gdf
    
    print("{:s}: Objekte: {:d} Attribute: {:d}:".format(shpFilename,gdf.shape[0],gdf.shape[1]))
    print(sorted(gdf.columns.to_list()))





shpFilenameLeitungen=[key for key in shapes.keys() if re.search('LEITUNGSABSCHNITT',key) != None][0]
shpLeitungen=shapes[shpFilenameLeitungen]


shpLeitungen['DN'].describe()


shpLeitungen.crs


minWidthinPixel=.75
maxWidthinPixel=5*minWidthinPixel
facWidthinPixelDN=1/200.

mLtg=shpLeitungen[~pd.isnull(shpLeitungen['geometry'])].sort_values(by=['DN'],ascending=True).explore(column='DN'
        ,cmap='cool_r',vmin=shpLeitungen['DN'].quantile(.20),vmax=shpLeitungen['DN'].quantile(.80)                                                           
        ,style_kwds={"style_function":lambda x: {"weight":min(max(x["properties"]["DN"]*facWidthinPixelDN,minWidthinPixel),maxWidthinPixel)}}
        ,tiles='CartoDB Positron' #'OpenStreetMap'
        ,name='shpLeitungen'                                                                                           
)


mLtg


shpFilenameUebergabestellen=[key for key in shapes.keys() if re.search('UEBERGABESTELLE',key) != None][0]
shpUebergabestellen=shapes[shpFilenameUebergabestellen]


shpUebergabestellen.describe()


shpUebergabestellen[pd.isnull(shpUebergabestellen['MIS_BEHAEL'])].describe()


gdfUe1=shpUebergabestellen[
(~pd.isnull(shpUebergabestellen['geometry']))
&
(~shpUebergabestellen['MIS_BEHAEL'].isin([0.,None,np.nan]))
]

gdfUe1["MIS_BEHAEL"].describe()



minRadius=2
maxRadius=10*minRadius
facRadius=1/1000.

mUe=gdfUe1.sort_values(by=['MIS_BEHAEL'],ascending=False).explode().explore(column='MIS_BEHAEL'
                                                                    ,cmap='autumn_r'
,vmin=gdfUe1["MIS_BEHAEL"].quantile(.025),vmax=gdfUe1["MIS_BEHAEL"].quantile(.975)
,style_kwds={"style_function":lambda x: {
    "radius":min(max(x["properties"]["MIS_BEHAEL"]*facRadius,minRadius),maxRadius) 
} 
}
        
 ,tiles='CartoDB Positron' #'OpenStreetMap'
,name='shpUebergabestellen'    
         )


mUe


dfLonLat=gdfUe1.to_crs("EPSG:4326").geometry.get_coordinates()
dfLonLat.head()


dfLonLatValue=pd.merge(gdfUe1,dfLonLat,left_index=True,right_index=True)[['x','y','MIS_BEHAEL']]
dfLonLatValue.head()


dfLonLatValue['xW']=dfLonLatValue.apply(lambda row: row['x']*row['MIS_BEHAEL'],axis=1)
dfLonLatValue['yW']=dfLonLatValue.apply(lambda row: row['y']*row['MIS_BEHAEL'],axis=1)


dfLonLatValue.mean()


xAvgW=dfLonLatValue['xW'].sum()/dfLonLatValue['MIS_BEHAEL'].sum()
yAvgW=dfLonLatValue['yW'].sum()/dfLonLatValue['MIS_BEHAEL'].sum()
xAvgW,yAvgW


heatMapData = [[row['y'],row['x'],row['MIS_BEHAEL']] for index, row in dfLonLatValue.iterrows()]


heatMapData[:3]


map = folium.Map(location=(yAvgW,xAvgW)
               ,tiles='CartoDB Positron' #'OpenStreetMap'
               ,zoom_start=11
              )
HeatMap(heatMapData,name='Heat Map von MIS_BEHAEL Radius 10 Größe 5',radius=10,blur=5,base=True).add_to(map)



shpLeitungen[~pd.isnull(shpLeitungen['geometry'])].sort_values(by=['DN'],ascending=True).explore(column='DN'
        ,cmap='cool_r',vmin=shpLeitungen['DN'].quantile(.20),vmax=shpLeitungen['DN'].quantile(.80)        
       #,legend=False
        ,style_kwds={"style_function":lambda x: {"weight":min(max(x["properties"]["DN"]*facWidthinPixelDN,minWidthinPixel),maxWidthinPixel)}}
       #,tiles='CartoDB Positron' #'OpenStreetMap'
        ,name='shpLeitungen'    
        ,m=map
)

gdfUe1[['MITGLIEDSN','MIS_UGSTID','MIS_BEHAEL','geometry']].explode().sort_values(by=['MIS_BEHAEL'],ascending=False).explore(column='MIS_BEHAEL'
      ,cmap='autumn_r',vmin=gdfUe1["MIS_BEHAEL"].quantile(.025),vmax=gdfUe1["MIS_BEHAEL"].quantile(.975)
     #,legend=False
      ,style_kwds={"style_function":lambda x: {"radius":min(max(x["properties"]["MIS_BEHAEL"]*facRadius,minRadius),maxRadius)}} 
     #,tiles='CartoDB Positron' #'OpenStreetMap'
      ,name='shpUebergabestellen'    
      ,m=map
)

dummy=folium.LayerControl().add_to(map)





map








df=pd.read_excel('Eingangsdaten_BWV.xlsx',header=1)
df.head()


df.rename(columns=
{col:"LF {:d}".format(idx+1) for idx,col in
enumerate([col for col in df.columns.to_list() if re.search('^BQ',col)])}
,inplace=True)
df.head()





modellKnotenNamen=sorted([name for name in m.dx.dataFrames['KNOT']['NAME'].values if name not in [None]])


modellKnotenNamen[:3],modellKnotenNamen[-3:]


'xW5428i1122' in modellKnotenNamen


UGSTID2Name=[]

for index, row in df.iterrows():
    pass
    #print(row)
    reExpStr='(?P<UGSTID>{:d})$'.format(int(row['UGSTID']))
    #print(reExpStr)
    matches=[]
    for name in modellKnotenNamen:
        #print(name)
        
        #if name=='xW5428i1122':
        #    print(name)
            
        
        
        mo=re.search(reExpStr,name)
        if mo != None:
            matches.append(name)
    UGSTID2Name.append(matches)


df['UGSTID2Name']=UGSTID2Name


df['UGSTID2NameFinal']=df['UGSTID2Name'].apply(lambda x: x[-1] if x != None else None)


df.head()





t0=pd.Timestamp(m.mx.df.index[0].strftime('%Y-%m-%d %X.%f'))


QM=('STAT',
  'KNOT~*~*~*~QM',
  t0,
  t0)


m.V3_KNOT['QM stat.']=m.V3_KNOT[QM]


dfMatch=pd.merge(df,m.V3_KNOT,left_on='UGSTID2NameFinal',right_on='NAME',how='left')


def testMatchKNOT():
    '''
    >>> df.shape[0]==dfMatch.shape[0]
    True
    >>> dfMatch[pd.isnull(dfMatch['NAME'])].shape[0]==0
    True
    '''
import doctest
doctest.testmod()


#sorted([col for col in dfMatch.columns.to_list() if not  isinstance(col,tuple)])


# 'NAME_QVAR'


dfMatch=dfMatch.filter(items=df.columns.to_list()+['QM stat.','NAME_QVAR',                                        
'fkQVAR',
 'XKOR',
 'YKOR'                                          
])


dfMatch.head()


dfMatchColsSoFar=dfMatch.columns.to_list()





dfQVAR=m.dx.dataFrames['V_BVZ_QVAR']


dfMatch=pd.merge(dfMatch
         ,dfQVAR[dfQVAR['lfdNrZEIT']==1]
         ,left_on='fkQVAR',right_on='pk',how='left'
         ,suffixes=('','_QVAR')
)


def testMatchQVAR():
    '''
    >>> df.shape[0]==dfMatch.shape[0]
    True
    >>> dfMatch[pd.isnull(dfMatch['NAME'])].shape[0]==0
    True
    '''
import doctest
doctest.testmod()


dfMatch=dfMatch.filter(items=dfMatchColsSoFar+['QM','pk_BZ','BESCHREIBUNG'                                       
])
dfMatch.head()








# Prinzip: Objekttyp (Tabelle), Attribut das geändert werden soll (hier Spalte QM), der Wert auf den das Attribut gesetzt werden soll (hier LF 1), Schluesseldaten
dfMatch['table']='QVAR_ROWT'
dfMatch['attrib']='QM'
dfMatch['attribValue']=dfMatch['LF 1'] # 'LF 2'
dfMatch['xk']='pk'
dfMatch['xkValue']=dfMatch['pk_BZ']


m.dx.update(dfMatch)





dfMatch['NAME']=dfMatch['NAME_QVAR']
dfMatch['TAG']=m.mx.df.index[0].strftime('%d.%m.%Y')
dfMatch['UHRZEIT']=m.mx.df.index[0].strftime('%H:%M')#:%S')
dfMatch['WERT']=-dfMatch['LF 1'] # 'LF 2'
dfMatch['PLS_ID']=dfMatch.apply(lambda row: "{!s:s} - ber. Wert IST: {:6.2f}".format(row['UGSTID'],row['QM stat.']),axis=1)


#dfMatch.head()


dfMatch[['NAME','TAG','UHRZEIT','WERT','BESCHREIBUNG','PLS_ID']].head()


dfMatch[['NAME','TAG','UHRZEIT','WERT','BESCHREIBUNG','PLS_ID']].sort_values(by=['PLS_ID']).to_csv('LF1 Prozessdatenimport.csv',sep=';',index=False)





dfs=[]
timestep=pd.Timedelta('3 Minutes')
for idx,lfCol in enumerate([col for col in dfMatch.columns.to_list() if re.search('^LF \d+',col)]):
    t=m.mx.df.index[0]+(idx+1)*timestep    
    dfMatch['WERT']=-dfMatch[lfCol]
    dfMatch['UHRZEIT']=t.strftime('%H:%M')#:%S')
    dfMatch['PLS_ID']=dfMatch.apply(lambda row: "{!s:s} - {:s} auf Zeitschritt {:d}".format(row['UGSTID'],lfCol,idx+1),axis=1)
    
    dfs.append(dfMatch[['NAME','TAG','UHRZEIT','WERT','BESCHREIBUNG','PLS_ID']])





dfMatch['UHRZEIT']=m.mx.df.index[0].strftime('%H:%M')#:%S')
dfMatch['WERT']=dfMatch['QM stat.'] 
dfMatch['PLS_ID']=dfMatch.apply(lambda row: "{!s:s} - ber. Wert IST auf Zeitschritt 0".format(row['UGSTID']),axis=1)
dfs.append(dfMatch[['NAME','TAG','UHRZEIT','WERT','BESCHREIBUNG','PLS_ID']])


pd.concat(dfs).sort_values(by=['NAME','UHRZEIT']).to_csv('LF alle Prozessdatenimport.csv',sep=';',index=False)











crs=gdfUe1.crs


gs=gpd.GeoSeries.from_wkb(m.V3_KNOT['GEOMWKB'],crs=crs)
gdf_KNOT=gpd.GeoDataFrame(m.V3_KNOT,geometry=gs,crs=crs)


#gdf_KNOT['NAME_QVAR'].unique()


#gdf_KNOT.columns.to_list()


#gdf_KNOT[
#    ~(pd.isnull(gdf_KNOT.geometry))
#]['NAME_QVAR'].unique()#[['NAME_QVAR','NAME','QM stat.']]


gdf_KNOTUe=gdf_KNOT[
    ~(pd.isnull(gdf_KNOT.geometry))
    &
    ~(gdf_KNOT['NAME_QVAR'].isin([None,np.nan]))
    &
    (gdf_KNOT.ID_CONT==gdf_KNOT.IDPARENT_CONT)    
][['geometry','NAME_QVAR','NAME','QM stat.']]
gdf_KNOTUe.head()


gdf_KNOTUe['UGSTID']=gdf_KNOTUe['NAME'].apply(lambda x: int(re.search("(?P<UGSTID>\d+)$",x).group('UGSTID')) if re.search("(?P<UGSTID>\d+)$",x)!=None else None)


gdf_KNOTUe.head()


gdf_KNOTUe.shape


gdf_KNOTUe=pd.merge(gdf_KNOTUe,shpUebergabestellen,left_on='UGSTID',right_on='MIS_UGSTID',how='left',suffixes=('','_shp')).filter(items=gdf_KNOTUe.columns.to_list()+['MITGLIEDSN','MIS_UGSTNA','geometry_shp'])
gdf_KNOTUe.head()


gdf_KNOTUe.shape


# Ue im Modell ohne Referenz im Shape
gdf_KNOTUe[pd.isnull(gdf_KNOTUe['geometry_shp'])]


gdf_KNOTUe=gdf_KNOTUe[~pd.isnull(gdf_KNOTUe['geometry_shp'])]


gdf_KNOTUe.shape


gdf_KNOTUe=pd.merge(gdf_KNOTUe,gdf_KNOTUe.groupby(by=['UGSTID']).count()[['NAME']],left_on='UGSTID',right_index=True,suffixes=('','_group')).rename(columns={'NAME_group':'AnzMatches'})


gdf_KNOTUe.shape


# Ue im Modell mit mehr als 1 Referenz im Shape 
gdf_KNOTUe[gdf_KNOTUe['AnzMatches']>1]


gdf_KNOTUe=gdf_KNOTUe[gdf_KNOTUe['AnzMatches']==1].reset_index(drop=True)


gdf_KNOTUe['geometry_shp']=gdf_KNOTUe['geometry_shp'].explode().reset_index()['geometry_shp']


gdf_KNOTUe.head()


gdf_KNOTUe['Abstand Shp Zu Sir3s']=gdf_KNOTUe['geometry_shp'].distance(gdf_KNOTUe['geometry'])


gdf_KNOTUe.head()


gdf_KNOTUe["QM stat."]=-gdf_KNOTUe["QM stat."].astype(float)


gdf_KNOTUe["QM stat."].describe()


(fmin,fmax)=gdfUe1["MIS_BEHAEL"].quantile(.025)/gdf_KNOTUe["QM stat."].quantile(.075),gdfUe1["MIS_BEHAEL"].quantile(.975)/gdf_KNOTUe["QM stat."].quantile(.975)

(fmin,fmax)
# facRaduis


gdf_KNOTUe[['NAME','UGSTID','MITGLIEDSN','MIS_UGSTNA','Abstand Shp Zu Sir3s','QM stat.','geometry']].sort_values(by=['QM stat.'],ascending=True).explore(column='QM stat.'
      ,cmap='autumn_r',vmin=gdf_KNOTUe["QM stat."].quantile(.075),vmax=gdf_KNOTUe["QM stat."].quantile(.975)
     ,legend=False
      ,style_kwds={"style_function":lambda x: {"radius":min(max(x["properties"]["QM stat."]*facRadius*max((fmin,fmax)),minRadius),maxRadius)}} 
     ,tiles='CartoDB Positron' #'OpenStreetMap'
      ,name='QM stat.'    
    #  ,m=map
)


dfLonLat=gdf_KNOTUe.to_crs("EPSG:4326").geometry.get_coordinates()
dfLonLat.head()


dfLonLatValue=pd.merge(gdf_KNOTUe,dfLonLat,left_index=True,right_index=True)[['x','y','QM stat.']]
dfLonLatValue.head()


heatMapDataQMstat = [[row['y'],row['x'],row['QM stat.']] for index, row in dfLonLatValue.iterrows()]





map = folium.Map(location=(yAvgW,xAvgW)
               ,tiles='CartoDB Positron' #'OpenStreetMap'
               ,zoom_start=11
              )

HeatMap(heatMapData,name='Heat Map von MIS_BEHAEL Radius 10 Größe 5',radius=10,blur=5,base=True,show=False).add_to(map)

HeatMap(heatMapDataQMstat,name='Heat Map von QM stat. Radius 10 Größe 5',radius=10,blur=5,base=True
       # ,show=False
       ).add_to(map)



shpLeitungen[~pd.isnull(shpLeitungen['geometry'])].sort_values(by=['DN'],ascending=True).explore(column='DN'
        ,cmap='cool_r',vmin=shpLeitungen['DN'].quantile(.20),vmax=shpLeitungen['DN'].quantile(.80)        
       #,legend=False
        ,style_kwds={"style_function":lambda x: {"weight":min(max(x["properties"]["DN"]*facWidthinPixelDN,minWidthinPixel),maxWidthinPixel)}}
       #,tiles='CartoDB Positron' #'OpenStreetMap'
        ,name='shpLeitungen'    
        ,m=map
)

gdfUe1[['MITGLIEDSN','MIS_UGSTID','MIS_BEHAEL','geometry']].explode().sort_values(by=['MIS_BEHAEL'],ascending=False).explore(column='MIS_BEHAEL'
      ,cmap='autumn_r',vmin=gdfUe1["MIS_BEHAEL"].quantile(.025),vmax=gdfUe1["MIS_BEHAEL"].quantile(.975)
     ,legend=False
      ,style_kwds={"style_function":lambda x: {"radius":min(max(x["properties"]["MIS_BEHAEL"]*facRadius,minRadius),maxRadius)}} 
     #,tiles='CartoDB Positron' #'OpenStreetMap'
      ,name='shpUebergabestellen'    
      ,m=map
      ,show=False                                                                                                                   
)


gdf_KNOTUe[['NAME','UGSTID','MITGLIEDSN','MIS_UGSTNA','Abstand Shp Zu Sir3s','QM stat.','geometry']].sort_values(by=['QM stat.'],ascending=True).explore(column='QM stat.'
      ,cmap='autumn_r',vmin=gdf_KNOTUe["QM stat."].quantile(.075),vmax=gdf_KNOTUe["QM stat."].quantile(.975)
     #,legend=False
      ,style_kwds={"style_function":lambda x: {"radius":min(max(x["properties"]["QM stat."]*facRadius*max((fmin,fmax)),minRadius),maxRadius)}} 
     #,tiles='CartoDB Positron' #'OpenStreetMap'
      ,name='QM stat.'    
      ,m=map
)
dummy=folium.LayerControl().add_to(map)





map





df=gdf_KNOTUe.groupby(by='MITGLIEDSN').agg({'QM stat.':[
    #'count',
    'sum']}).reset_index()
df.columns=df.columns.droplevel(1)
df=df.sort_values(by='QM stat.',ascending=False).reset_index(drop=True)
df


df['QM stat.'].describe()


df['QM stat.'].quantile(.33)


df['MITGLIEDSN']=df.apply(lambda row: row['MITGLIEDSN'] if row['QM stat.'] > df['QM stat.'].quantile(.33) else 'Rest' ,axis=1)


df


df=df.groupby(by='MITGLIEDSN').agg({'QM stat.':[
    #'count',
    'sum']}).reset_index()
df.columns=df.columns.droplevel(1)
df=df.sort_values(by='QM stat.',ascending=False).reset_index(drop=True)
df


def highlight_max(s, props=''):
    return np.where(s == np.nanmax(s.values), props, '')


dfExp=df.style.format({\
    'QM stat.':'{:5.0f}',\
})\
.background_gradient(cmap='Blues')\
.apply(highlight_max, props='color:white;background-color:pink;',subset=['QM stat.'], axis=0)\
.hide(axis='index')
dfExp


dfExp.to_excel('BspTabellenexport.xlsx',index=False)



