


import logging
import os
import sys

import pandas as pd
import sqlite3


import geopandas
import numpy as np
import math
import importlib
import re

import doctest

import matplotlib.pyplot as plt
#import matplotlib.dates as mdates

import matplotlib

import matplotlib.patches as mpatches

#import matplotlib.gridspec as gridspec

#from matplotlib import cm
#from matplotlib.colors import ListedColormap
#import matplotlib.font_manager as font_manager
#import matplotlib.patheffects as path_effects

#import contextily as cx

import pickle

import xml.etree.ElementTree as ET

logger = logging.getLogger('FW Bad Salzuflen')  

logFileName= r"FW Bad Salzuflen.log" 

loglevel = logging.DEBUG
logging.basicConfig(filename=logFileName
                        ,filemode='w'
                        ,level=loglevel
                        ,format="%(asctime)s ; %(name)-60s ; %(levelname)-7s ; %(message)s")    

fileHandler = logging.FileHandler(logFileName)     

logger.addHandler(fileHandler)

consoleHandler = logging.StreamHandler()
consoleHandler.setFormatter(logging.Formatter("%(levelname)-7s ; %(message)s"))
consoleHandler.setLevel(logging.INFO)
logger.addHandler(consoleHandler)





dbFilename="FW Bad Salzuflen"





try:
    from PT3S import dxAndMxHelperFcts
except:
    import dxAndMxHelperFcts


 importlib.reload(dxAndMxHelperFcts)   


m=dxAndMxHelperFcts.readDxAndMx(dbFile=os.path.join('.',dbFilename+'.db3'))





dfLAYR=m.dfLAYR


dfLAYR.head()


dfUpd=dfLAYR[dfLAYR['TYPE'].isin(['KNOT'])].head()[['TYPE','ID']]
dfUpd


xk=dfLAYR[dfLAYR['NAME'].isin(['Test'])]['tk'].iloc[0]


#sorted(dfLAYR['NAME'].unique())


dfUpd['table']='LAYR'


dfUpd['attrib']='OBJS'


dfUpd['xk']='tk'


dfUpd['xkValue']=xk


dfUpd['attribValue']=dfUpd.apply(lambda row: "{:s}~{:s}\t".format(row['TYPE'],row['ID']).encode('utf-8'),axis=1)


dfUpd


dfUpd.dtypes


dfUpd2=dfUpd.groupby(by=['xkValue']).agg({'xkValue': 'first'
                                   ,'table': 'first'
                                   ,'attrib': 'first'
                                   ,'xk': 'first'
                                   , 'attribValue': 'sum'}).reset_index(drop=True)
dfUpd2['attribValue']=dfUpd2['attribValue'].apply(lambda x: x.rstrip())
dfUpd2


#m.dx.update(dfUpd2)








dfWBLZ=m.dfWBLZ


dfWBLZ.head()


m.V3_WBLZ





dx=m.dx


mx=m.mx





V3_FWVB=dx.dataFrames['FWVB']
# kann zu diesem "Skriptzeitpunkt" nur Sachdaten enthalten da SIR 3S ja in der Modell-DB keine Ergebnisse mehr abspeichert


sorted(V3_FWVB.columns.to_list())


V3_FWVB.describe()


V3_FWVB.head(10)





V3_FWVB.head(2)








mx.df.columns
#mx.df enthält aus Lesezeit- und auch Arbeitsspeichergründen keine "Vektorergebnisse"  





# enthält "Vektorergebnisse" für STAT, TMIN, TNAX:
mx.dfVecAggs.index


mx.dfVecAggs.index








V3_FWVB=m.V3_FWVB





# dito:
V3_ROHR=m.V3_ROHR
V3_KNOT=m.V3_KNOT





V3_VBEL=m.dx.dataFrames['V3_VBEL']


V3_VBEL.head()


#V3_VBEL.columns.to_list()





#V3_VBEL.loc[('FWVB',slice(None)),:].reset_index().head().columns.to_list()


df_FWVB=V3_VBEL.loc[('FWVB',slice(None)),:].reset_index()[['OBJID','NAME_i','NAME_k','fkKI','fkKK','W0','fkLFKT']]


df_FWVB.head()


dfx=pd.merge(df_FWVB,dx.dataFrames['V_BVZ_LFKT'],left_on='fkLFKT', right_on='pk',suffixes=('','_LFKT')).filter(items=df_FWVB.columns.to_list()+['NAME']).rename(columns={'NAME':'LFKT_NAME'})


df_FWVB.shape,dfx.shape


df_FWVB=dfx





df_ROHR=V3_VBEL.loc[('ROHR',slice(None)),:].reset_index()[['OBJID','NAME_i','NAME_k','fkKI','fkKK','BESCHREIBUNG']]


df_ROHR.head()





# QMAVAbs: Rohrdurchfluss absolut stationär
# dW: Sollleistung-Istleistung stationär 


t0=pd.Timestamp(mx.df.index[0].strftime('%Y-%m-%d %X.%f'))





QMAV=('STAT'
            ,'ROHR~*~*~*~QMAV'
            ,t0
            ,t0
            )
QMAV


V3_ROHR['QMAVAbs']=V3_ROHR.apply(lambda row: math.fabs(row[QMAV]) ,axis=1)





WSOLL=('STAT'
            ,'FWVB~*~*~*~WSOLL'
            ,t0
            ,t0
            )
WSOLL


W=('STAT'
            ,'FWVB~*~*~*~W'
            ,t0
            ,t0
            )
W


V3_FWVB['dW']=V3_FWVB.apply(lambda row: row[WSOLL]-row[W] ,axis=1)


V3_FWVB.groupby(by='NAME_LFKT').sum()['dW'].filter(regex='^PrN')


V3_FWVB['W']=V3_FWVB[W] # geopandas mag keine nicht flachen Spaltennamen ...


V3_FWVB['dummy']=1





# vorher "QGIS Export" in SIR 3S
# in Oldenburg muss die aufkommende Frage mit Nein beantwortet werden


crs='EPSG:25832' 

gs=geopandas.GeoSeries.from_wkb(V3_FWVB['GEOMWKB'],crs=crs)
gdf_FWVB=geopandas.GeoDataFrame(V3_FWVB,geometry=gs,crs=crs)

gs=geopandas.GeoSeries.from_wkb(V3_ROHR['GEOMWKB'],crs=crs)
gdf_ROHR=geopandas.GeoDataFrame(V3_ROHR,geometry=gs,crs=crs)


ma=gdf_ROHR[gdf_ROHR['KVR'].isin([1.,None])].loc[:,['geometry', 'QMAVAbs']].explore(color = 'grey')
gdf_FWVB.loc[:,['geometry','W']].explore(color='red',m=ma)





# man kann sich mehr Mühe geben ...


cmap_color_ROHR='DI'
norm_min_ROHR=gdf_ROHR[cmap_color_ROHR].min()
norm_max_ROHR=gdf_ROHR[cmap_color_ROHR].max()
norm_ROHR_color = plt.Normalize(vmin=norm_min_ROHR, vmax=norm_max_ROHR)
colors_ROHR = ['lightgray', 'dimgray']
cmap_ROHR = matplotlib.colors.LinearSegmentedColormap.from_list('ROHR', colors_ROHR, N = 256)
cmap_ROHR


cmap_color_ROHRErg='QMAVAbs'
norm_min_ROHRErg=gdf_ROHR[cmap_color_ROHRErg].min()
norm_max_ROHRErg=gdf_ROHR[cmap_color_ROHRErg].max()
norm_ROHRErg_color = plt.Normalize(vmin=norm_min_ROHRErg, vmax=norm_max_ROHRErg)
colors_ROHRErg = ['darkgreen','magenta']
cmap_ROHRErg = matplotlib.colors.LinearSegmentedColormap.from_list('ROHRErg', colors_ROHRErg, N = 256)
cmap_ROHRErg


cmap_color_FWVB='W'
norm_min_FWVB=gdf_FWVB[gdf_FWVB['NAME_CONT'].isin(['M-1-0-1'])][cmap_color_FWVB].min()
norm_max_FWVB=gdf_FWVB[gdf_FWVB['NAME_CONT'].isin(['M-1-0-1'])][cmap_color_FWVB].max()
norm_FWVB_color = plt.Normalize(vmin=norm_min_FWVB, vmax=norm_max_FWVB)
colors_FWVB = ['oldlace', 'orange']
cmap_FWVB = matplotlib.colors.LinearSegmentedColormap.from_list('FWVB', colors_FWVB, N = 256)
cmap_FWVB


cmap_ROHRFac=0.0125*1.5 
cmap_FWVBFac=0.0125


ma=gdf_FWVB[gdf_FWVB['NAME_CONT'].isin(['M-1-0-1'])].loc[:,['W','geometry']].sort_values(by=['W'],ascending=False).explore(
style_kwds=dict(
    style_function=                                 
            lambda x: {                 
                 'weight': x['properties']['W']*cmap_FWVBFac
                ,'color':  matplotlib.colors.to_hex(cmap_FWVB(norm_FWVB_color(x['properties']['W'])))     
                       }                     
             ),  
    marker_kwds=dict(#radius=0.25,
                     fill=False
                    ,color='black'
                    ),
    marker_type="circle_marker",    
) 

m2=gdf_ROHR[gdf_ROHR['KVR'].isin([1])].loc[:,['DI','geometry']].sort_values(by=['DI'],ascending=True).explore(
m=ma,
style_kwds=dict(
    style_function=                                 
            lambda x: {                 
                 'weight': x['properties']['DI']*cmap_ROHRFac
                ,'color':  matplotlib.colors.to_hex(cmap_ROHR(norm_ROHR_color(x['properties']['DI'])))     
                       }                     
             ),                           
) 
gdf_ROHR[gdf_ROHR['KVR'].isin([1])].loc[:,[cmap_color_ROHRErg,'geometry']].sort_values(by=[cmap_color_ROHRErg],ascending=True).explore(
m=m2,
style_kwds=dict(
    style_function=                                 
            lambda x: {                 
                 'weight': x['properties'][cmap_color_ROHRErg]*cmap_ROHRFac
                ,'color':  matplotlib.colors.to_hex(cmap_ROHRErg(norm_ROHRErg_color(x['properties'][cmap_color_ROHRErg])))     
                       }                     
             ),                           
) 




# wenn man Karten-interaktiv arbeiten will sollte man zu QGIS gehen
# Skripting wie gezeigt hat seine Stärken in der generierenden Analyse und der Generierung von Reports
# nicht nur NFDs sondern auch Zeitkurven, Längsschnitte und Kombis der Darstellungsformen auf einem (PDF-)Blatt oder in einem PDF-Buch

# dank der transparenten Datenstruktur von SIR 3S kann ja jede Anwenderin außerhalb von SIR 3S nehmen was sie will ...





try:
    from PT3S import Rm
except:
    import Rm


# von wo wurde geladen ...
importlib.reload(Rm)


try:
    from PT3S import pNFD
except:
    import pNFD


# von wo wurde geladen ...
importlib.reload(pNFD)


#gdf_ROHR.columns.to_list()


cmap_color_ROHR='DI'
norm_min_ROHR=gdf_ROHR[cmap_color_ROHR].min()
norm_max_ROHR=gdf_ROHR[cmap_color_ROHR].max()
norm_ROHR_color = plt.Normalize(vmin=norm_min_ROHR, vmax=norm_max_ROHR)
colors_ROHR = ['oldlace', 'orange']
cmap_ROHR2 = matplotlib.colors.LinearSegmentedColormap.from_list('ROHR', colors_ROHR, N = 256)
cmap_ROHR2





def plotLogo(axSrc
        ,dfSrc
        ,logoFile=r"C:\Users\wolters\3S\HuM\SimKI-Mop\trunk\Bad Salzuflen\Version 1\SimKI-Mop Logo.png"
        ,dxAxesLogo=.125
       ,leftLogo=.875
       ,bottomLogo=.025
       ,dxAxesBlocksyms=.125*0.25
        ):
        
    import matplotlib.pyplot as plt
    import numpy as np
    from PIL import Image
    
    # Logo SimKI ###################
    img = np.asarray(Image.open(logoFile))
    dxIm=1266#1800.
    dyIm=1244#1698.
    
    dyAxesLogo=dyIm/dxIm*dxAxesLogo
    
    import matplotlib
    ax= plt.axes([leftLogo,bottomLogo, dxAxesLogo, dyAxesLogo])    
    ax.imshow(img,aspect='equal',alpha=.5)
    ax.axis('off')
        
    # Logo Blocksymbole #############################
    erzFile=r"C:\Users\wolters\3S\HuM\SimKI-Mop\trunk\Bad Salzuflen\Version 1\bhkw.png"
    img = np.asarray(Image.open(erzFile))
    
    dxIm=186
    dyIm=148
    
    dyAxesBlocksyms=dyIm/dxIm*dxAxesBlocksyms
    
    #  Blatt #################
        
    left,right=axSrc.get_xlim()
    bottom,top=axSrc.get_ylim()
    #print(left,right)

    dxSrc=right-left
    dySrc=top-bottom
    
    # Blocksymbole
    
    for index, row in dfSrc.iterrows():
        
        X=row['XKOR']
        Y=row['YKOR']
        XRel=(X-left)/dxSrc - dxAxesBlocksyms/2
        YRel=(Y-bottom)/dySrc - dyAxesBlocksyms/2
        
        ax= plt.axes([XRel
                  ,YRel
                  , dxAxesBlocksyms, dyAxesBlocksyms])    
        ax.imshow(img,aspect='equal',alpha=.5)
        ax.axis('off')         


#gdf_ROHR


dfLAYR[dfLAYR['NAME'].isin(['Verbund Staatsb.-Hoffmann VL'])]['ID'].values


 gdf_ROHR_Vb_StaatsHoff = gdf_ROHR[
            gdf_ROHR['tk'].isin(dfLAYR[dfLAYR['NAME'].isin(['Verbund Staatsb.-Hoffmann VL'])]['ID'].values)
        ]#.sort_values(by=['DI'],ascending=True)    


gdf_ROHR_Vb_StaatsHoff2 = gdf_ROHR[
            gdf_ROHR['tk'].isin(dfLAYR[dfLAYR['NAME'].isin(['Verbund Staatsb.-Hoffmann 2 VL'])]['ID'].values)
        ]#.sort_values(by=['DI'],ascending=True)  


gdf_ROHR_Vb_ZiegelStaats = gdf_ROHR[
            gdf_ROHR['tk'].isin(dfLAYR[dfLAYR['NAME'].isin(['Verbund ZiegelStaatsb. VL'])]['ID'].values)
        ]#.sort_values(by=['DI'],ascending=True)  


gdf_ROHR_Vb=pd.concat([gdf_ROHR_Vb_StaatsHoff,gdf_ROHR_Vb_StaatsHoff2,gdf_ROHR_Vb_ZiegelStaats]).sort_values(by=['DI'],ascending=True)  


gdf_ROHR_Vb['DI'].describe()


gdf_ROHR_Vb.shape


# von wo wurde geladen ...
importlib.reload(pNFD)


#gdf_FWVB.columns.to_list()





# Plotten
fig=plt.figure(figsize=Rm.DINA2q,dpi=Rm.dpiSize)

ax=fig.gca()

attr_colors_ROHR_Sach_patches,attr_colors_ROHR_Erg_patches,attr_colors_FWVB_Sach_patches,attr_colors_FWVB_Erg_patches,dummy=pNFD.pNFD_FW(
        ax=ax,
    
        # ROHR
        gdf_ROHR = gdf_ROHR[            
            (gdf_ROHR['KVR'].isin([1]))
            &
            (gdf_ROHR['QMAVAbs']>0.10)
        ].sort_values(by=['DI'],ascending=True)    
    
       ,norm_min_ROHR_Sach=0    
       ,norm_max_ROHR_Sach=300
       ,attr_colors_ROHR_Sach_patches_fmt="{:4.0f}"
       ,attr_colors_ROHR_Sach_patchValues=[25,100,150,200,250,300]
    
       ,attr_colors_ROHR_Erg='QMAVAbs'
       ,lws_ROHR_Erg_Sach=False    
       ,norm_max_ROHR_Erg=300
       ,attr_colors_ROHR_Erg_patches_fmt="{:4.0f}"   
       ,attr_colors_ROHR_Erg_patchValues=[25,100,150,200,250,300]
        
        # FWVB
       ,gdf_FWVB = gdf_FWVB[
           gdf_FWVB['NAME_CONT'].isin(['M-1-0-1'])
           &
           gdf_FWVB['W0']>0.01       
       ].sort_values(by=['W'],ascending=False)       
       ,attr_colors_FWVB_Erg='W'
       ,norm_min_FWVB_Erg = 500 
       ,attr_colors_FWVB_Erg_patchValues= [500,1000,2000,3000,4000,5000,6000]
       ,attr_colors_FWVB_Erg_patches_fmt="{:4.0f}"     
    
       ,MapOn=False
           
       )


attr_colors_ROHR_Sach_patchesVb,dummy,dummy,dummy,dummy=pNFD.pNFD_FW(
        ax=ax,
    
        gdf_ROHR = gdf_ROHR_Vb.sort_values(by=['DI'],ascending=True)    
    
       ,attr_colors_ROHR_Erg=None
       ,norm_min_ROHR_Sach=0    
       ,norm_max_ROHR_Sach=300    
       ,colors_ROHR_Sach = ['oldlace', 'orange']
       ,attr_colors_ROHR_Sach_patches_fmt="{:4.0f}"
       ,attr_colors_ROHR_Sach_patchValues=[200,250]    
    
       ,MapOn=False       
       )

attr_colors_ROHR_Sach_patchesX,dummy,attr_colors_FWVB_Sach_patchesX,dummy,dummy=pNFD.pNFD_FW(
        ax=ax,
    
        gdf_ROHR = gdf_ROHR [            
            (gdf_ROHR['KVR'].isin([1]))
            &
            ~(gdf_ROHR['QMAVAbs']>0.10)
            &
            ~(gdf_ROHR['tk'].isin(gdf_ROHR_Vb['tk'].values))
            &            
            ~(gdf_ROHR['tk'].isin(dfLAYR[dfLAYR['NAME'].isin(['Verbund ZiegelStaatsb. 2 VL'])]['ID'].values))            
        ].sort_values(by=['DI'],ascending=True)    
    
       ,attr_colors_ROHR_Erg=None
       ,norm_min_ROHR_Sach=0    
       ,norm_max_ROHR_Sach=300    
       ,colors_ROHR_Sach = ['lightsteelblue', 'cornflowerblue']
       ,attr_colors_ROHR_Sach_zOrder=6
       ,attr_colors_ROHR_Sach_patches_fmt="{:4.0f}"
       ,attr_colors_ROHR_Sach_patchValues=[25,100,150,200,250,300]
      # ,attr_colors_ROHR_Sach_patchValues=[200,250]    
    
        # FWVB
       ,gdf_FWVB = gdf_FWVB[
           (gdf_FWVB['NAME_CONT'].isin(['M-1-0-1']))
           &
           ~(gdf_FWVB['W0']>0.01)       
       ]#.sort_values(by=['W0'],ascending=False)       
       ,attr_colors_FWVB_Sach='dummy'
       ,attr_colors_FWVB_Sach_zOrder=5
       ,attr_ms_FWVB_Sach='dummy' 
       ,colors_FWVB_Sach = ['lavender', 'powderblue'] 
       #,norm_min_FWVB_Sach=0.9    
       #,norm_max_FWVB_Sach=1.1    
       ,fac_ms_FWVB=8000./15
       #,norm_min_FWVB_Erg = 0 
       ,attr_colors_FWVB_Sach_patchValues= [1]
       ,attr_colors_FWVB_Sach_patches_fmt="{:4.0f}"         
    
       ,MapOn=False  
       )

trenn_patchDNIst = mpatches.Patch(color='white', label='DN (innen) breitenskaliert nach DN:',alpha=.01)
trenn_patchQIst = mpatches.Patch(color='white', label='Fluss t/h breitenskaliert nach t/h (0-max.Fluss=Breite DN 300) dargestellt auf DN (innen):',alpha=.01)
trenn_patchW = mpatches.Patch(color='white', label='Kunden SimKI-Mop: (Anschluss-)Leistung realtiv zueinander (max. := 6000) größenskaliert nach Leistung:',alpha=.01)
trenn_patchDN = mpatches.Patch(color='white', label='in SimKI-Mop zu berücksichtigende Verbundleitungen breitenskaliert nach DN:',alpha=.01)

trenn_attr_colors_ROHR_Sach_patchesX=mpatches.Patch(color='white', label='Leitungen in SimKI-Mop vsl. nicht zu berücksichtigen:',alpha=.01)
trenn_attr_colors_FWVB_Sach_patchesX=mpatches.Patch(color='white', label='Kunden in SimKI-Mop vsl. nicht zu berücksichtigen:',alpha=.01)

ax.legend(handles=
              
              [trenn_patchDNIst]+attr_colors_ROHR_Sach_patches
             +[trenn_patchQIst]+attr_colors_ROHR_Erg_patches
             +[trenn_patchW]+attr_colors_FWVB_Erg_patches
             +[trenn_patchDN]+attr_colors_ROHR_Sach_patchesVb
             +[trenn_attr_colors_ROHR_Sach_patchesX]+attr_colors_ROHR_Sach_patchesX
             +[trenn_attr_colors_FWVB_Sach_patchesX]+attr_colors_FWVB_Sach_patchesX
#             +[trenn_patchW]+attr_colors_FWVB_Erg_patches2
             ,loc='upper left'
             ,facecolor='white', framealpha=.01)


plotLogo(ax
,V3_KNOT[~pd.isnull(V3_KNOT['NAME_CONT_VKNO'])][['NAME_CONT_VKNO'
                                               # ,'NAME'
                                                ,'XKOR','YKOR']].groupby(by=['NAME_CONT_VKNO']).mean())

import contextily as cx
cx.add_basemap(ax, crs=gdf_ROHR.crs.to_string(), source = cx.providers.CartoDB.Positron, zoom = 15)

plt.tight_layout() 

plt.savefig('NFDBsp.pdf',dpi=2*Rm.dpiSize)
plt.savefig('NFDBsp.png',dpi=2*Rm.dpiSize)


axAlt=ax
axAlt.get_xlim()





sorted([col for col in mx.df if re.search('^WBLZ',col)])


tMaxG2=mx.df['WBLZ~G2Staats~~5196639304551047703~WES'].idxmax().tz_convert(None)+pd.Timedelta('1 hour')



G2StaatsNodeIDs=dfWBLZ[dfWBLZ['NAME'].isin(['G2Staats'])]['ID'].values


gdf_ROHR_G2Staats = gdf_ROHR[
            (gdf_ROHR['fkKI'].isin(G2StaatsNodeIDs))
            &
            (gdf_ROHR['fkKK'].isin(G2StaatsNodeIDs))
            &
            (gdf_ROHR['QMAVAbs']>0.10)
            &
            (gdf_ROHR['KVR'].isin([1]))
]


gdf_FWVB_G2Staats = gdf_FWVB[
            (gdf_FWVB['fkKI'].isin(G2StaatsNodeIDs))
            &
            (gdf_FWVB['fkKK'].isin(G2StaatsNodeIDs))
            &
            (gdf_FWVB['NAME_CONT'].isin(['M-1-0-1']))
            &
            (gdf_FWVB['W0']>0.01)
]


G1HoffLohNodeIDs=dfWBLZ[dfWBLZ['NAME'].isin(['G1HoffLoh'])]['ID'].values


gdf_ROHR_G1HoffLoh = gdf_ROHR[
            (gdf_ROHR['fkKI'].isin(G1HoffLohNodeIDs))
            &
            (gdf_ROHR['fkKK'].isin(G1HoffLohNodeIDs))
            &
            (gdf_ROHR['QMAVAbs']>0.10)
            &
            (gdf_ROHR['KVR'].isin([1]))
]


gdf_FWVB_G1HoffLoh = gdf_FWVB[
            (gdf_FWVB['fkKI'].isin(G1HoffLohNodeIDs))
            &
            (gdf_FWVB['fkKK'].isin(G1HoffLohNodeIDs))
            &
            (gdf_FWVB['NAME_CONT'].isin(['M-1-0-1']))
            &
            (gdf_FWVB['W0']>0.01)
]


G3ZiegelNodeIDs=dfWBLZ[dfWBLZ['NAME'].isin(['G3Ziegel'])]['ID'].values


gdf_ROHR_G3Ziegel = gdf_ROHR[
            (gdf_ROHR['fkKI'].isin(G3ZiegelNodeIDs))
            &
            (gdf_ROHR['fkKK'].isin(G3ZiegelNodeIDs))
            &
            (gdf_ROHR['QMAVAbs']>0.10)
            &
            (gdf_ROHR['KVR'].isin([1]))
]


gdf_FWVB_G3Ziegel = gdf_FWVB[
            (gdf_FWVB['fkKI'].isin(G3ZiegelNodeIDs))
            &
            (gdf_FWVB['fkKK'].isin(G3ZiegelNodeIDs))
            &
            (gdf_FWVB['NAME_CONT'].isin(['M-1-0-1']))
            &
            (gdf_FWVB['W0']>0.01)
]


tA=pd.Timestamp(mx.df.index[0].strftime('%Y-%m-%d %X.%f'))
tE=pd.Timestamp(mx.df.index[-1].strftime('%Y-%m-%d %X.%f'))


idxWES=('TMAX','WBLZ~*~*~*~WES',tA,tE)
idxWVB=('TMAX','WBLZ~*~*~*~WVB',tA,tE)
#idxWVERL=('TMAX','WBLZ~*~*~*~WVERL',tA,tE)


m.V3_WBLZ#[m.V3_WBLZ['NAME']=='G2Staats']


# Plotten
fig=plt.figure(figsize=Rm.DINA2q,dpi=Rm.dpiSize)

ax=fig.gca()

for gdfR,gdfF,cm in zip([gdf_ROHR_G2Staats,gdf_ROHR_G1HoffLoh,gdf_ROHR_G3Ziegel],[gdf_FWVB_G2Staats,gdf_FWVB_G1HoffLoh,gdf_FWVB_G3Ziegel],[['pink', 'hotpink'],['plum', 'violet'],['lightblue', 'lightskyblue']]):
            attr_colors_ROHR_Sach_patches,attr_colors_ROHR_Erg_patches,attr_colors_FWVB_Sach_patches,attr_colors_FWVB_Erg_patches,dummy=pNFD.pNFD_FW(
                    ax=ax

  
            # ROHR
           ,gdf_ROHR = gdfR.sort_values(by=['DI'],ascending=True)   # kleine zuerst (große ueber kleine)  

           ,attr_colors_ROHR_Erg=None
           ,norm_min_ROHR_Sach=0    
           ,norm_max_ROHR_Sach=300    
           ,colors_ROHR_Sach = cm#['pink', 'hotpink']
           ,attr_colors_ROHR_Sach_patches_fmt="{:4.0f}"
           ,attr_colors_ROHR_Sach_patchValues=[25,100,150,200,250,300]        
            # FWVB
           ,gdf_FWVB = gdfF.sort_values(by=['W'],ascending=False) # große zuerst (kleine ueber große)       
           ,attr_colors_FWVB_Erg='W'
           ,norm_min_FWVB_Erg = 500 
           ,attr_colors_FWVB_Erg_patches_fmt="{:4.0f}" 
           ,attr_colors_FWVB_Erg_patchValues= [500,1000,2000,3000,4000,5000,6000]       
    
           ,MapOn=False 

           )

s=m.V3_WBLZ[m.V3_WBLZ['NAME']=='G2Staats'].iloc[0]
patchG2Staats = mpatches.Patch(color='hotpink', label=' Wärmebilanz Staatsbad:\n {tMax:s}\n {WESTxt:s} {WES:5.2f} MW \n {WVBTxt:s} {WVB:5.2f} MW \n {WVERLTxt:s} {WVERL:5.2f}\n {WpKmTxt:s} {WpKm:5.2f} \n {WpVolTxt:s} {WpVol:5.2f}'.format(
                                                                                                                                               tMax=str(tMaxG2)  
                                                                                                                                              ,WES=s[idxWES]
                                                                                                                                              ,WVB=s[idxWVB]
                                                                                                                                              ,WVERL=(s[idxWES]-s[idxWVB])/s[idxWES]*100
                                                                                                                                              ,WpKm=s[idxWVB]/(gdf_ROHR_G2Staats['L'].sum()/1000)
                                                                                                                                              ,WpVol=s[idxWVB]/(gdf_ROHR_G2Staats['V'].sum())
                                                                                                                                              ,WESTxt='Erzeugung:'.ljust(18)
                                                                                                                                              ,WVBTxt='Last:'.ljust(18)
                                                                                                                                              ,WVERLTxt='Verluste in %:'.ljust(18)
                                                                                                                                              ,WpKmTxt='MW pro km Ltg.:'.ljust(18)
                                                                                                                                              ,WpVolTxt='MW pro m3 Heizw.:'.ljust(18)
                                                                                                                                              )                              
                              )
s=m.V3_WBLZ[m.V3_WBLZ['NAME']=='G1HoffLoh'].iloc[0]
patchG1HoffLoh = mpatches.Patch(color='violet', label=' Wärmebilanz Hoffmann/Lohfeld:\n STWBSU Planstand\n {WESTxt:s} {WES:5.2f} MW \n {WVBTxt:s} {WVB:5.2f} MW \n {WVERLTxt:s} {WVERL:5.2f}\n {WpKmTxt:s} {WpKm:5.2f} \n {WpVolTxt:s} {WpVol:5.2f}'.format(
                                                                                                                                               tMax=str(tMaxG2)  
                                                                                                                                              ,WES=s[idxWES]
                                                                                                                                              ,WVB=s[idxWVB]
                                                                                                                                              ,WVERL=(s[idxWES]-s[idxWVB])/s[idxWES]*100
                                                                                                                                              ,WpKm=s[idxWVB]/(gdf_ROHR_G2Staats['L'].sum()/1000)
                                                                                                                                              ,WpVol=s[idxWVB]/(gdf_ROHR_G2Staats['V'].sum())
                                                                                                                                              ,WESTxt='Erzeugung:'.ljust(18)
                                                                                                                                              ,WVBTxt='Last:'.ljust(18)
                                                                                                                                              ,WVERLTxt='Verluste in %:'.ljust(18)
                                                                                                                                              ,WpKmTxt='MW pro km Ltg.:'.ljust(18)
                                                                                                                                              ,WpVolTxt='MW pro m3 Heizw.:'.ljust(18)
                                                                                                                                              )                              
                              )

s=m.V3_WBLZ[m.V3_WBLZ['NAME']=='G3Ziegel'].iloc[0]
patchG3Ziegel  = mpatches.Patch(color='lightskyblue', label=' Wärmebilanz Ziegelstr.:\n STWBSU Planstand\n {WESTxt:s} {WES:5.2f} MW \n {WVBTxt:s} {WVB:5.2f} MW \n {WVERLTxt:s} {WVERL:5.2f}\n {WpKmTxt:s} {WpKm:5.2f} \n {WpVolTxt:s} {WpVol:5.2f}'.format(
                                                                                                                                               tMax=str(tMaxG2)  
                                                                                                                                              ,WES=s[idxWES]
                                                                                                                                              ,WVB=s[idxWVB]
                                                                                                                                              ,WVERL=(s[idxWES]-s[idxWVB])/s[idxWES]*100
                                                                                                                                              ,WpKm=s[idxWVB]/(gdf_ROHR_G2Staats['L'].sum()/1000)
                                                                                                                                              ,WpVol=s[idxWVB]/(gdf_ROHR_G2Staats['V'].sum())
                                                                                                                                              ,WESTxt='Erzeugung:'.ljust(18)
                                                                                                                                              ,WVBTxt='Last:'.ljust(18)
                                                                                                                                              ,WVERLTxt='Verluste in %:'.ljust(18)
                                                                                                                                              ,WpKmTxt='MW pro km Ltg.:'.ljust(18)
                                                                                                                                              ,WpVolTxt='MW pro m3 Heizw.:'.ljust(18)
                                                                                                                                              )                              
                              )

import matplotlib.font_manager as font_manager
font = font_manager.FontProperties(family='monospace',
                                   weight='bold',
                                   style='normal', size=16)

G2StaatsL=ax.legend(handles=              
              [patchG2Staats]          
             ,loc='upper right'
          #   ,facecolor='white'
          ,prop=font
          , framealpha=.01)


G1HoffLohL=ax.legend(handles=              
              [patchG1HoffLoh]          
             ,loc='upper right'
             ,bbox_to_anchor=(0.5, 0., 0.5, 0.75)
          #   ,facecolor='white'
          ,prop=font
          , framealpha=.01)

G3ZiegelL=ax.legend(handles=              
              [patchG3Ziegel]          
             ,loc='upper left'
          #   ,facecolor='white'
          ,prop=font
          , framealpha=.01)




from matplotlib import pyplot
pyplot.gca().add_artist(G2StaatsL)
pyplot.gca().add_artist(G1HoffLohL)

ax.set_xlim(axAlt.get_xlim())
ax.set_ylim(axAlt.get_ylim())

plotLogo(ax
,V3_KNOT[~pd.isnull(V3_KNOT['NAME_CONT_VKNO'])][['NAME_CONT_VKNO'
                                               # ,'NAME'
                                                ,'XKOR','YKOR']].groupby(by=['NAME_CONT_VKNO']).mean())



import contextily as cx
cx.add_basemap(ax, crs=gdf_ROHR.crs.to_string(), source = cx.providers.CartoDB.Positron, zoom = 15)

plt.tight_layout() 

plt.savefig('NFDBspMitWblz.pdf',dpi=2*Rm.dpiSize)
plt.savefig('NFDBspMitWblz.png',dpi=2*Rm.dpiSize)





dfLAYR.head()


s="KNOT~123\t".encode('utf-8')+"KNOT~456\t".encode('utf-8')  
s


s.decode('utf-8').split('\t')



