<!DOCTYPE html>

<html lang="en" data-content_root="../">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>} &#8212; PT3S 90.14.15.0.dev1 documentation</title>
    <link rel="stylesheet" type="text/css" href="../_static/pygments.css?v=b3523f8e" />
    <link rel="stylesheet" type="text/css" href="../_static/alabaster.css?v=cb25574f" />
    <link rel="stylesheet" type="text/css" href="../_static/custom.css?v=3277e099" />
    <script src="../_static/documentation_options.js?v=cdfdd26d"></script>
    <script src="../_static/doctools.js?v=888ff710"></script>
    <script src="../_static/sphinx_highlight.js?v=dc90522c"></script>
    <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    <script>window.MathJax = {"tex": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true}, "options": {"ignoreHtmlClass": "tex2jax_ignore|mathjax_ignore|document", "processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
    <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          

          <div class="body" role="main">
            
  <p>import os
import logging</p>
<p>logger = logging.getLogger()</p>
<p>logFileName= r”BWV.log”</p>
<p>loglevel = logging.DEBUG
logging.basicConfig(filename=logFileName</p>
<blockquote>
<div><p>,filemode=’w’
,level=loglevel
,format=”%(asctime)s ; %(name)-60s ; %(levelname)-7s ; %(message)s”)</p>
</div></blockquote>
<p>fileHandler = logging.FileHandler(logFileName)</p>
<p>logger.addHandler(fileHandler)</p>
<p>consoleHandler = logging.StreamHandler()
consoleHandler.setFormatter(logging.Formatter(“%(levelname)-7s ; %(message)s”))</p>
<p>consoleHandler.setLevel(logging.INFO) # ggf. DEBUG/WARNING/ERROR
logger.addHandler(consoleHandler)</p>
<p>import pandas as pd
import geopandas as gpd
import networkx as nx
import glob
import re
import numpy as np
import folium
from folium.plugins import HeatMap
import doctest</p>
<p>dbFilename=”BWV”</p>
<p>!pip install PT3S -U –no-deps</p>
<dl class="simple">
<dt>try:</dt><dd><p>from PT3S import dxAndMxHelperFcts</p>
</dd>
<dt>except:</dt><dd><p>import dxAndMxHelperFcts</p>
</dd>
<dt>m=dxAndMxHelperFcts.readDxAndMx(dbFile=os.path.join(‘.’,dbFilename+’.db3’)</dt><dd><p>#,forceSir3sRead=True
#,preventPklDump=True
)</p>
</dd>
</dl>
<p>shapes={}
for shpFile in glob.glob(r”.GIS Daten*.shp”):</p>
<blockquote>
<div><p>gdf=gpd.read_file(shpFile)</p>
<p>shpFilename=os.path.basename(shpFile)
shpFilename,tail=os.path.splitext(shpFilename)
shapes[shpFilename]=gdf</p>
<p>print(“{:s}: Objekte: {:d} Attribute: {:d}:”.format(shpFilename,gdf.shape[0],gdf.shape[1]))
print(sorted(gdf.columns.to_list()))</p>
</div></blockquote>
<p>shpFilenameLeitungen=[key for key in shapes.keys() if re.search(‘LEITUNGSABSCHNITT’,key) != None][0]
shpLeitungen=shapes[shpFilenameLeitungen]</p>
<p>shpLeitungen[‘DN’].describe()</p>
<p>shpLeitungen.crs</p>
<p>minWidthinPixel=.75
maxWidthinPixel=5*minWidthinPixel
facWidthinPixelDN=1/200.</p>
<dl class="simple">
<dt>mLtg=shpLeitungen[~pd.isnull(shpLeitungen[‘geometry’])].sort_values(by=[‘DN’],ascending=True).explore(column=’DN’</dt><dd><p>,cmap=’cool_r’,vmin=shpLeitungen[‘DN’].quantile(.20),vmax=shpLeitungen[‘DN’].quantile(.80)
,style_kwds={“style_function”:lambda x: {“weight”:min(max(x[“properties”][“DN”]*facWidthinPixelDN,minWidthinPixel),maxWidthinPixel)}}
,tiles=’CartoDB Positron’ #’OpenStreetMap’
,name=’shpLeitungen’</p>
</dd>
</dl>
<p>)</p>
<p>mLtg</p>
<p>shpFilenameUebergabestellen=[key for key in shapes.keys() if re.search(‘UEBERGABESTELLE’,key) != None][0]
shpUebergabestellen=shapes[shpFilenameUebergabestellen]</p>
<p>shpUebergabestellen.describe()</p>
<p>shpUebergabestellen[pd.isnull(shpUebergabestellen[‘MIS_BEHAEL’])].describe()</p>
<p>gdfUe1=shpUebergabestellen[
(~pd.isnull(shpUebergabestellen[‘geometry’]))
&amp;
(~shpUebergabestellen[‘MIS_BEHAEL’].isin([0.,None,np.nan]))
]</p>
<p>gdfUe1[“MIS_BEHAEL”].describe()</p>
<p>minRadius=2
maxRadius=10*minRadius
facRadius=1/1000.</p>
<dl class="simple">
<dt>mUe=gdfUe1.sort_values(by=[‘MIS_BEHAEL’],ascending=False).explode().explore(column=’MIS_BEHAEL’</dt><dd><p>,cmap=’autumn_r’</p>
</dd>
</dl>
<p>,vmin=gdfUe1[“MIS_BEHAEL”].quantile(.025),vmax=gdfUe1[“MIS_BEHAEL”].quantile(.975)
,style_kwds={“style_function”:lambda x: {</p>
<blockquote>
<div><p>“radius”:min(max(x[“properties”][“MIS_BEHAEL”]*facRadius,minRadius),maxRadius)</p>
</div></blockquote>
<section id="}">
<h1>}<a class="headerlink" href="#}" title="Link to this heading">¶</a></h1>
<blockquote>
<div><p>,tiles=’CartoDB Positron’ #’OpenStreetMap’</p>
</div></blockquote>
<dl class="simple">
<dt>,name=’shpUebergabestellen’</dt><dd><p>)</p>
</dd>
</dl>
<p>mUe</p>
<p>dfLonLat=gdfUe1.to_crs(“EPSG:4326”).geometry.get_coordinates()
dfLonLat.head()</p>
<p>dfLonLatValue=pd.merge(gdfUe1,dfLonLat,left_index=True,right_index=True)[[‘x’,’y’,’MIS_BEHAEL’]]
dfLonLatValue.head()</p>
<p>dfLonLatValue[‘xW’]=dfLonLatValue.apply(lambda row: row[‘x’]*row[‘MIS_BEHAEL’],axis=1)
dfLonLatValue[‘yW’]=dfLonLatValue.apply(lambda row: row[‘y’]*row[‘MIS_BEHAEL’],axis=1)</p>
<p>dfLonLatValue.mean()</p>
<p>xAvgW=dfLonLatValue[‘xW’].sum()/dfLonLatValue[‘MIS_BEHAEL’].sum()
yAvgW=dfLonLatValue[‘yW’].sum()/dfLonLatValue[‘MIS_BEHAEL’].sum()
xAvgW,yAvgW</p>
<p>heatMapData = [[row[‘y’],row[‘x’],row[‘MIS_BEHAEL’]] for index, row in dfLonLatValue.iterrows()]</p>
<p>heatMapData[:3]</p>
<dl>
<dt>map = folium.Map(location=(yAvgW,xAvgW)</dt><dd><blockquote>
<div><p>,tiles=’CartoDB Positron’ #’OpenStreetMap’
,zoom_start=11</p>
</div></blockquote>
<p>)</p>
</dd>
</dl>
<p>HeatMap(heatMapData,name=’Heat Map von MIS_BEHAEL Radius 10 Größe 5’,radius=10,blur=5,base=True).add_to(map)</p>
<dl>
<dt>shpLeitungen[~pd.isnull(shpLeitungen[‘geometry’])].sort_values(by=[‘DN’],ascending=True).explore(column=’DN’</dt><dd><blockquote>
<div><p>,cmap=’cool_r’,vmin=shpLeitungen[‘DN’].quantile(.20),vmax=shpLeitungen[‘DN’].quantile(.80)</p>
</div></blockquote>
<dl class="simple">
<dt>#,legend=False</dt><dd><p>,style_kwds={“style_function”:lambda x: {“weight”:min(max(x[“properties”][“DN”]*facWidthinPixelDN,minWidthinPixel),maxWidthinPixel)}}</p>
</dd>
<dt>#,tiles=’CartoDB Positron’ #’OpenStreetMap’</dt><dd><p>,name=’shpLeitungen’
,m=map</p>
</dd>
</dl>
</dd>
</dl>
<p>)</p>
<dl>
<dt>gdfUe1[[‘MITGLIEDSN’,’MIS_UGSTID’,’MIS_BEHAEL’,’geometry’]].explode().sort_values(by=[‘MIS_BEHAEL’],ascending=False).explore(column=’MIS_BEHAEL’</dt><dd><blockquote>
<div><p>,cmap=’autumn_r’,vmin=gdfUe1[“MIS_BEHAEL”].quantile(.025),vmax=gdfUe1[“MIS_BEHAEL”].quantile(.975)</p>
</div></blockquote>
<dl class="simple">
<dt>#,legend=False</dt><dd><p>,style_kwds={“style_function”:lambda x: {“radius”:min(max(x[“properties”][“MIS_BEHAEL”]*facRadius,minRadius),maxRadius)}}</p>
</dd>
<dt>#,tiles=’CartoDB Positron’ #’OpenStreetMap’</dt><dd><p>,name=’shpUebergabestellen’
,m=map</p>
</dd>
</dl>
</dd>
</dl>
<p>)</p>
<p>dummy=folium.LayerControl().add_to(map)</p>
<p>map</p>
<p>df=pd.read_excel(‘Eingangsdaten_BWV.xlsx’,header=1)
df.head()</p>
<p>df.rename(columns=
{col:”LF {:d}”.format(idx+1) for idx,col in
enumerate([col for col in df.columns.to_list() if re.search(‘^BQ’,col)])}
,inplace=True)
df.head()</p>
<p>modellKnotenNamen=sorted([name for name in m.dx.dataFrames[‘KNOT’][‘NAME’].values if name not in [None]])</p>
<p>modellKnotenNamen[:3],modellKnotenNamen[-3:]</p>
<p>‘xW5428i1122’ in modellKnotenNamen</p>
<p>UGSTID2Name=[]</p>
<dl>
<dt>for index, row in df.iterrows():</dt><dd><p>pass
#print(row)
reExpStr=’(?P&lt;UGSTID&gt;{:d})$’.format(int(row[‘UGSTID’]))
#print(reExpStr)
matches=[]
for name in modellKnotenNamen:</p>
<blockquote>
<div><p>#print(name)</p>
<p>#if name==’xW5428i1122’:
#    print(name)</p>
<p>mo=re.search(reExpStr,name)
if mo != None:</p>
<blockquote>
<div><p>matches.append(name)</p>
</div></blockquote>
</div></blockquote>
<p>UGSTID2Name.append(matches)</p>
</dd>
</dl>
<p>df[‘UGSTID2Name’]=UGSTID2Name</p>
<p>df[‘UGSTID2NameFinal’]=df[‘UGSTID2Name’].apply(lambda x: x[-1] if x != None else None)</p>
<p>df.head()</p>
<p>t0=pd.Timestamp(m.mx.df.index[0].strftime(‘%Y-%m-%d %X.%f’))</p>
<dl class="simple">
<dt>QM=(‘STAT’,</dt><dd><p>‘KNOT~*~*~*~QM’,
t0,
t0)</p>
</dd>
</dl>
<p>m.V3_KNOT[‘QM stat.’]=m.V3_KNOT[QM]</p>
<p>dfMatch=pd.merge(df,m.V3_KNOT,left_on=’UGSTID2NameFinal’,right_on=’NAME’,how=’left’)</p>
<dl class="simple">
<dt>def testMatchKNOT():</dt><dd><p>‘’’
&gt;&gt;&gt; df.shape[0]==dfMatch.shape[0]
True
&gt;&gt;&gt; dfMatch[pd.isnull(dfMatch[‘NAME’])].shape[0]==0
True
‘’’</p>
</dd>
</dl>
<p>import doctest
doctest.testmod()</p>
<p>#sorted([col for col in dfMatch.columns.to_list() if not  isinstance(col,tuple)])</p>
<p># ‘NAME_QVAR’</p>
<p>dfMatch=dfMatch.filter(items=df.columns.to_list()+[‘QM stat.’,’NAME_QVAR’,
‘fkQVAR’,</p>
<blockquote>
<div><p>‘XKOR’,
‘YKOR’</p>
</div></blockquote>
<p>])</p>
<p>dfMatch.head()</p>
<p>dfMatchColsSoFar=dfMatch.columns.to_list()</p>
<p>dfQVAR=m.dx.dataFrames[‘V_BVZ_QVAR’]</p>
<dl class="simple">
<dt>dfMatch=pd.merge(dfMatch</dt><dd><p>,dfQVAR[dfQVAR[‘lfdNrZEIT’]==1]
,left_on=’fkQVAR’,right_on=’pk’,how=’left’
,suffixes=(‘’,’_QVAR’)</p>
</dd>
</dl>
<p>)</p>
<dl class="simple">
<dt>def testMatchQVAR():</dt><dd><p>‘’’
&gt;&gt;&gt; df.shape[0]==dfMatch.shape[0]
True
&gt;&gt;&gt; dfMatch[pd.isnull(dfMatch[‘NAME’])].shape[0]==0
True
‘’’</p>
</dd>
</dl>
<p>import doctest
doctest.testmod()</p>
<p>dfMatch=dfMatch.filter(items=dfMatchColsSoFar+[‘QM’,’pk_BZ’,’BESCHREIBUNG’
])
dfMatch.head()</p>
<p># Prinzip: Objekttyp (Tabelle), Attribut das geändert werden soll (hier Spalte QM), der Wert auf den das Attribut gesetzt werden soll (hier LF 1), Schluesseldaten
dfMatch[‘table’]=’QVAR_ROWT’
dfMatch[‘attrib’]=’QM’
dfMatch[‘attribValue’]=dfMatch[‘LF 1’] # ‘LF 2’
dfMatch[‘xk’]=’pk’
dfMatch[‘xkValue’]=dfMatch[‘pk_BZ’]</p>
<p>m.dx.update(dfMatch)</p>
<p>dfMatch[‘NAME’]=dfMatch[‘NAME_QVAR’]
dfMatch[‘TAG’]=m.mx.df.index[0].strftime(‘%d.%m.%Y’)
dfMatch[‘UHRZEIT’]=m.mx.df.index[0].strftime(‘%H:%M’)#:%S’)
dfMatch[‘WERT’]=-dfMatch[‘LF 1’] # ‘LF 2’
dfMatch[‘PLS_ID’]=dfMatch.apply(lambda row: “{!s:s} - ber. Wert IST: {:6.2f}”.format(row[‘UGSTID’],row[‘QM stat.’]),axis=1)</p>
<p>#dfMatch.head()</p>
<p>dfMatch[[‘NAME’,’TAG’,’UHRZEIT’,’WERT’,’BESCHREIBUNG’,’PLS_ID’]].head()</p>
<p>dfMatch[[‘NAME’,’TAG’,’UHRZEIT’,’WERT’,’BESCHREIBUNG’,’PLS_ID’]].sort_values(by=[‘PLS_ID’]).to_csv(‘LF1 Prozessdatenimport.csv’,sep=’;’,index=False)</p>
<p>dfs=[]
timestep=pd.Timedelta(‘3 Minutes’)
for idx,lfCol in enumerate([col for col in dfMatch.columns.to_list() if re.search(‘^LF d+’,col)]):</p>
<blockquote>
<div><p>t=m.mx.df.index[0]+(idx+1)*timestep
dfMatch[‘WERT’]=-dfMatch[lfCol]
dfMatch[‘UHRZEIT’]=t.strftime(‘%H:%M’)#:%S’)
dfMatch[‘PLS_ID’]=dfMatch.apply(lambda row: “{!s:s} - {:s} auf Zeitschritt {:d}”.format(row[‘UGSTID’],lfCol,idx+1),axis=1)</p>
<p>dfs.append(dfMatch[[‘NAME’,’TAG’,’UHRZEIT’,’WERT’,’BESCHREIBUNG’,’PLS_ID’]])</p>
</div></blockquote>
<p>dfMatch[‘UHRZEIT’]=m.mx.df.index[0].strftime(‘%H:%M’)#:%S’)
dfMatch[‘WERT’]=dfMatch[‘QM stat.’]
dfMatch[‘PLS_ID’]=dfMatch.apply(lambda row: “{!s:s} - ber. Wert IST auf Zeitschritt 0”.format(row[‘UGSTID’]),axis=1)
dfs.append(dfMatch[[‘NAME’,’TAG’,’UHRZEIT’,’WERT’,’BESCHREIBUNG’,’PLS_ID’]])</p>
<p>pd.concat(dfs).sort_values(by=[‘NAME’,’UHRZEIT’]).to_csv(‘LF alle Prozessdatenimport.csv’,sep=’;’,index=False)</p>
<p>crs=gdfUe1.crs</p>
<p>gs=gpd.GeoSeries.from_wkb(m.V3_KNOT[‘GEOMWKB’],crs=crs)
gdf_KNOT=gpd.GeoDataFrame(m.V3_KNOT,geometry=gs,crs=crs)</p>
<p>#gdf_KNOT[‘NAME_QVAR’].unique()</p>
<p>#gdf_KNOT.columns.to_list()</p>
<p>#gdf_KNOT[
#    ~(pd.isnull(gdf_KNOT.geometry))
#][‘NAME_QVAR’].unique()#[[‘NAME_QVAR’,’NAME’,’QM stat.’]]</p>
<dl class="simple">
<dt>gdf_KNOTUe=gdf_KNOT[</dt><dd><p>~(pd.isnull(gdf_KNOT.geometry))
&amp;
~(gdf_KNOT[‘NAME_QVAR’].isin([None,np.nan]))
&amp;
(gdf_KNOT.ID_CONT==gdf_KNOT.IDPARENT_CONT)</p>
</dd>
</dl>
<p>][[‘geometry’,’NAME_QVAR’,’NAME’,’QM stat.’]]
gdf_KNOTUe.head()</p>
<p>gdf_KNOTUe[‘UGSTID’]=gdf_KNOTUe[‘NAME’].apply(lambda x: int(re.search(“(?P&lt;UGSTID&gt;d+)$”,x).group(‘UGSTID’)) if re.search(“(?P&lt;UGSTID&gt;d+)$”,x)!=None else None)</p>
<p>gdf_KNOTUe.head()</p>
<p>gdf_KNOTUe.shape</p>
<p>gdf_KNOTUe=pd.merge(gdf_KNOTUe,shpUebergabestellen,left_on=’UGSTID’,right_on=’MIS_UGSTID’,how=’left’,suffixes=(‘’,’_shp’)).filter(items=gdf_KNOTUe.columns.to_list()+[‘MITGLIEDSN’,’MIS_UGSTNA’,’geometry_shp’])
gdf_KNOTUe.head()</p>
<p>gdf_KNOTUe.shape</p>
<p># Ue im Modell ohne Referenz im Shape
gdf_KNOTUe[pd.isnull(gdf_KNOTUe[‘geometry_shp’])]</p>
<p>gdf_KNOTUe=gdf_KNOTUe[~pd.isnull(gdf_KNOTUe[‘geometry_shp’])]</p>
<p>gdf_KNOTUe.shape</p>
<p>gdf_KNOTUe=pd.merge(gdf_KNOTUe,gdf_KNOTUe.groupby(by=[‘UGSTID’]).count()[[‘NAME’]],left_on=’UGSTID’,right_index=True,suffixes=(‘’,’_group’)).rename(columns={‘NAME_group’:’AnzMatches’})</p>
<p>gdf_KNOTUe.shape</p>
<p># Ue im Modell mit mehr als 1 Referenz im Shape
gdf_KNOTUe[gdf_KNOTUe[‘AnzMatches’]&gt;1]</p>
<p>gdf_KNOTUe=gdf_KNOTUe[gdf_KNOTUe[‘AnzMatches’]==1].reset_index(drop=True)</p>
<p>gdf_KNOTUe[‘geometry_shp’]=gdf_KNOTUe[‘geometry_shp’].explode().reset_index()[‘geometry_shp’]</p>
<p>gdf_KNOTUe.head()</p>
<p>gdf_KNOTUe[‘Abstand Shp Zu Sir3s’]=gdf_KNOTUe[‘geometry_shp’].distance(gdf_KNOTUe[‘geometry’])</p>
<p>gdf_KNOTUe.head()</p>
<p>gdf_KNOTUe[“QM stat.”]=-gdf_KNOTUe[“QM stat.”].astype(float)</p>
<p>gdf_KNOTUe[“QM stat.”].describe()</p>
<p>(fmin,fmax)=gdfUe1[“MIS_BEHAEL”].quantile(.025)/gdf_KNOTUe[“QM stat.”].quantile(.075),gdfUe1[“MIS_BEHAEL”].quantile(.975)/gdf_KNOTUe[“QM stat.”].quantile(.975)</p>
<p>(fmin,fmax)
# facRaduis</p>
<dl>
<dt>gdf_KNOTUe[[‘NAME’,’UGSTID’,’MITGLIEDSN’,’MIS_UGSTNA’,’Abstand Shp Zu Sir3s’,’QM stat.’,’geometry’]].sort_values(by=[‘QM stat.’],ascending=True).explore(column=’QM stat.’</dt><dd><blockquote>
<div><blockquote>
<div><p>,cmap=’autumn_r’,vmin=gdf_KNOTUe[“QM stat.”].quantile(.075),vmax=gdf_KNOTUe[“QM stat.”].quantile(.975)</p>
</div></blockquote>
<dl class="simple">
<dt>,legend=False</dt><dd><p>,style_kwds={“style_function”:lambda x: {“radius”:min(max(x[“properties”][“QM stat.”]*facRadius*max((fmin,fmax)),minRadius),maxRadius)}}</p>
</dd>
<dt>,tiles=’CartoDB Positron’ #’OpenStreetMap’</dt><dd><p>,name=’QM stat.’</p>
</dd>
</dl>
</div></blockquote>
<p>#  ,m=map</p>
</dd>
</dl>
<p>)</p>
<p>dfLonLat=gdf_KNOTUe.to_crs(“EPSG:4326”).geometry.get_coordinates()
dfLonLat.head()</p>
<p>dfLonLatValue=pd.merge(gdf_KNOTUe,dfLonLat,left_index=True,right_index=True)[[‘x’,’y’,’QM stat.’]]
dfLonLatValue.head()</p>
<p>heatMapDataQMstat = [[row[‘y’],row[‘x’],row[‘QM stat.’]] for index, row in dfLonLatValue.iterrows()]</p>
<dl>
<dt>map = folium.Map(location=(yAvgW,xAvgW)</dt><dd><blockquote>
<div><p>,tiles=’CartoDB Positron’ #’OpenStreetMap’
,zoom_start=11</p>
</div></blockquote>
<p>)</p>
</dd>
</dl>
<p>HeatMap(heatMapData,name=’Heat Map von MIS_BEHAEL Radius 10 Größe 5’,radius=10,blur=5,base=True,show=False).add_to(map)</p>
<dl>
<dt>HeatMap(heatMapDataQMstat,name=’Heat Map von QM stat. Radius 10 Größe 5’,radius=10,blur=5,base=True</dt><dd><p># ,show=False
).add_to(map)</p>
</dd>
<dt>shpLeitungen[~pd.isnull(shpLeitungen[‘geometry’])].sort_values(by=[‘DN’],ascending=True).explore(column=’DN’</dt><dd><blockquote>
<div><p>,cmap=’cool_r’,vmin=shpLeitungen[‘DN’].quantile(.20),vmax=shpLeitungen[‘DN’].quantile(.80)</p>
</div></blockquote>
<dl class="simple">
<dt>#,legend=False</dt><dd><p>,style_kwds={“style_function”:lambda x: {“weight”:min(max(x[“properties”][“DN”]*facWidthinPixelDN,minWidthinPixel),maxWidthinPixel)}}</p>
</dd>
<dt>#,tiles=’CartoDB Positron’ #’OpenStreetMap’</dt><dd><p>,name=’shpLeitungen’
,m=map</p>
</dd>
</dl>
</dd>
</dl>
<p>)</p>
<dl>
<dt>gdfUe1[[‘MITGLIEDSN’,’MIS_UGSTID’,’MIS_BEHAEL’,’geometry’]].explode().sort_values(by=[‘MIS_BEHAEL’],ascending=False).explore(column=’MIS_BEHAEL’</dt><dd><blockquote>
<div><p>,cmap=’autumn_r’,vmin=gdfUe1[“MIS_BEHAEL”].quantile(.025),vmax=gdfUe1[“MIS_BEHAEL”].quantile(.975)</p>
</div></blockquote>
<dl class="simple">
<dt>,legend=False</dt><dd><p>,style_kwds={“style_function”:lambda x: {“radius”:min(max(x[“properties”][“MIS_BEHAEL”]*facRadius,minRadius),maxRadius)}}</p>
</dd>
<dt>#,tiles=’CartoDB Positron’ #’OpenStreetMap’</dt><dd><p>,name=’shpUebergabestellen’
,m=map
,show=False</p>
</dd>
</dl>
</dd>
</dl>
<p>)</p>
<dl>
<dt>gdf_KNOTUe[[‘NAME’,’UGSTID’,’MITGLIEDSN’,’MIS_UGSTNA’,’Abstand Shp Zu Sir3s’,’QM stat.’,’geometry’]].sort_values(by=[‘QM stat.’],ascending=True).explore(column=’QM stat.’</dt><dd><blockquote>
<div><p>,cmap=’autumn_r’,vmin=gdf_KNOTUe[“QM stat.”].quantile(.075),vmax=gdf_KNOTUe[“QM stat.”].quantile(.975)</p>
</div></blockquote>
<dl class="simple">
<dt>#,legend=False</dt><dd><p>,style_kwds={“style_function”:lambda x: {“radius”:min(max(x[“properties”][“QM stat.”]*facRadius*max((fmin,fmax)),minRadius),maxRadius)}}</p>
</dd>
<dt>#,tiles=’CartoDB Positron’ #’OpenStreetMap’</dt><dd><p>,name=’QM stat.’
,m=map</p>
</dd>
</dl>
</dd>
</dl>
<p>)
dummy=folium.LayerControl().add_to(map)</p>
<p>map</p>
<dl class="simple">
<dt>df=gdf_KNOTUe.groupby(by=’MITGLIEDSN’).agg({‘QM stat.’:[</dt><dd><p>#’count’,
‘sum’]}).reset_index()</p>
</dd>
</dl>
<p>df.columns=df.columns.droplevel(1)
df=df.sort_values(by=’QM stat.’,ascending=False).reset_index(drop=True)
df</p>
<p>df[‘QM stat.’].describe()</p>
<p>df[‘QM stat.’].quantile(.33)</p>
<p>df[‘MITGLIEDSN’]=df.apply(lambda row: row[‘MITGLIEDSN’] if row[‘QM stat.’] &gt; df[‘QM stat.’].quantile(.33) else ‘Rest’ ,axis=1)</p>
<p>df</p>
<dl class="simple">
<dt>df=df.groupby(by=’MITGLIEDSN’).agg({‘QM stat.’:[</dt><dd><p>#’count’,
‘sum’]}).reset_index()</p>
</dd>
</dl>
<p>df.columns=df.columns.droplevel(1)
df=df.sort_values(by=’QM stat.’,ascending=False).reset_index(drop=True)
df</p>
<dl class="simple">
<dt>def highlight_max(s, props=’’):</dt><dd><p>return np.where(s == np.nanmax(s.values), props, ‘’)</p>
</dd>
<dt>dfExp=df.style.format({</dt><dd><p>‘QM stat.’:’{:5.0f}’,</p>
</dd>
</dl>
<p>}).background_gradient(cmap=’Blues’).apply(highlight_max, props=’color:white;background-color:pink;’,subset=[‘QM stat.’], axis=0).hide(axis=’index’)
dfExp</p>
<p>dfExp.to_excel(‘BspTabellenexport.xlsx’,index=False)</p>
</section>


          </div>
          
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<h1 class="logo"><a href="../index.html">PT3S</a></h1>








<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../installation.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../functions.html">Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../releases.html">Releases</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>








        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2024, 3S Consult GmbH.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 7.2.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
      |
      <a href="../_sources/.virtual_documents/BWV.ipynb.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>